
% TP CoCodages JPEG et MPEG-2 - 3SN-M - 2022

%--------------------------------------------------------------------------
% Fonction de compression JPEG d'une image
%--------------------------------------------------------------------------
% [I_Codee,Poids,Compression,nb_coeffs_AC,nb_coeffs_DC] = 
%                        CompressionJPEG(I_Origine,canal,methode,F_Qualite)
%
% sorties : I_Codee = image de DCT quantifiee
%           Poids = poids de l'image d'origine en ko pour les differentes
%                   etapes de la compression
%           Compression = taux de compression final
%           nb_coeffs_AC = nombre de coefficients AC dans l'image compressee
%           nb_coeffs_DC = nombre de coefficients DC dans l'image compressee
% 
% entrees : I_Origine = image originale (ou residuelle)
%           canal = canal pour le choix de la table de quantification :
%                   'Luminance', 'Chrominance' ou 'Residu'
%           methode = methode de calcul de la DCT : 'Matlab' ou 'Rapide'
%           F_Qualite = facteur de qualite pour la compression
%--------------------------------------------------------------------------
% Fonctions a coder/utiliser : DCT2DParBlocs.m
%                              QuantificationDCT.m
%                              CodageEntropique.m
%                              CoefficientsACDC.m
%--------------------------------------------------------------------------

function [I_Codee, Poids, Compression, nb_coeffs_AC, nb_coeffs_DC] = ...
                         CompressionJPEG(I_Origine, canal, methode, F_Qualite)

    % Taille des blocs pour la DCT
    taille_bloc = 8;
    
    % 1. Transformation DCT par blocs
    I_DCT = DCT2DParBlocs('Direct', I_Origine, methode, taille_bloc);

    % 2. Quantification des coefficients DCT
    I_Quant = QuantificationDCT('Direct', I_DCT, canal, F_Qualite, taille_bloc);
    
    % 3. Extraction des coefficients AC et DC
    [Coeff_AC, Coeff_DC] = CoefficientsACDC(I_Quant, taille_bloc);
    
    % 4. Codage entropique pour les coefficients AC et DC
    % Calcul de l'entropie et du poids en utilisant CodageEntropique
    [poids_AC, H_AC] = CodageEntropique(Coeff_AC);
    [poids_DC, H_DC] = CodageEntropique(Coeff_DC);
    
    % Poids total en ko (somme des poids AC et DC)
    Poids.H_JPEG = poids_AC + poids_DC;
    
    % Taille initiale en ko (8 bits par pixel)
    Poids.Origine = numel(I_Origine) * 8 / (8 * 1024);
    
    % 5. Calcul du taux de compression
    Compression = (1 - (Poids.H_JPEG / Poids.Origine))*100;

    % Nombre de coefficients AC/DC
    nb_coeffs_AC = numel(Coeff_AC);
    nb_coeffs_DC = numel(Coeff_DC);

    % Sortie de l'image compressée
    I_Codee = I_Quant;  % Image quantifiée (codée) en sortie
end





%--------------------------------------------------------------------------
% Fonction de recuperation des coefficients AC/DC de la DCT par blocs
%--------------------------------------------------------------------------
%[Coeff_AC_Image, Coeff_DC_Image] = CoefficientsACDC(I_Quant, taille_bloc)
%
% sortie : Coeff_AC = vecteur reunissant tous les coefficients AC de 
%                     l'image jusqu'au dernier coefficient non nul 
%                     (taille variable)
%          Coeff_DC = vecteur reunissant tous les coefficients DC de
%                     l'image (taille fixe) 
% 
% entree : I_Quant = Image de DCT quantifiee
%          taille_bloc = taille des blocs pour la DCT (ici 8x8)
%--------------------------------------------------------------------------
function [Coeff_AC, Coeff_DC] = CoefficientsACDC(I_Quant, taille_bloc)
    [h, w] = size(I_Quant);
    nb_blocs_h = h / taille_bloc;
    nb_blocs_w = w / taille_bloc;
    
    Coeff_AC = [];
    Coeff_DC = zeros(nb_blocs_h * nb_blocs_w, 1);
    
    for i = 1:nb_blocs_h
        for j = 1:nb_blocs_w
            % Extraire le bloc quantifié de taille 8x8
            bloc = I_Quant((i-1)*taille_bloc+1:i*taille_bloc, ...
                           (j-1)*taille_bloc+1:j*taille_bloc);
            
            % Extraire le coefficient DC (position [1,1] dans le bloc)
            Coeff_DC((i-1)*nb_blocs_w + j) = bloc(1,1);
            
            % Extraction des coefficients AC en utilisant le parcours zigzag
            Vecteur_zigzag = ParcoursBlocZigzag(bloc, taille_bloc^2);
            
            % Supprimer les zéros en fin de vecteur AC et ajouter EOB
            Vecteur_zigzag = Vecteur_zigzag(2:end);  % Supprimer le DC en premier
            idx_non_zero = find(Vecteur_zigzag ~= 0, 1, 'last');  % Dernier non zéro
            if isempty(idx_non_zero)
                Vecteur_zigzag = 1000;  % Pas de coefficients AC, uniquement EOB = 1000
            else
                Vecteur_zigzag = [Vecteur_zigzag(1:idx_non_zero), 1000]; % EOB à la fin
            end
            
            % Ajouter les coefficients AC au vecteur global
            Coeff_AC = [Coeff_AC, Vecteur_zigzag];
        end
    end
end



%--------------------------------------------------------------------------
% Fonction de parcours d'un bloc en zigzag pour recuperer les coefficients
% AC/DC de la DCT
%--------------------------------------------------------------------------
% Vecteur_zigzag = ParcoursBlocZigzag(Bloc_DCT,nb_pixels)
%
% sortie : Vecteur_zigzag = vecteur des coefficients DC/AC ordonnes du bloc
% 
% entrée : Bloc_DCT = DCT du bloc courant
%          nb_pixels = nombre de pixels dans le bloc
%--------------------------------------------------------------------------
function Vecteur_zigzag = ParcoursBlocZigzag(Bloc_DCT,nb_pixels)
    % Initialisation du vecteur qui contiendra les coefficients
    Vecteur_zigzag = zeros(1,nb_pixels);
    % Remplissage en partant du debut et de la fin
    for k = 1:nb_pixels/2
        n = ceil(sqrt(2*k+1/4)-0.5);
        temp = k - n*(n-1)/2;
        if (mod(n,2) < 1)
            i = temp; 
        else
            i = n + 1 - temp;
        end
        j = n + 1 - i;
        % Positionnement des coefficients dans le vecteur
        Vecteur_zigzag(k) = Bloc_DCT(i,j);
        Vecteur_zigzag(65-k) = Bloc_DCT(9-j,9-i);
    end
end




